import Foundation
import Combine

enum PlistFileLocation: String {
    // Mobile Gestalt
    case resolution = "/var/Managed Preferences/mobile/com.apple.iokit.IOMobileGraphicsFamily.plist"
    
    // Springboard Options
    case springboard = "/var/Managed Preferences/mobile/com.apple.springboard.plist"
    case footnote = "/var/containers/Shared/SystemGroup/systemgroup.com.apple.configurationprofiles/Library/ConfigurationProfiles/SharedDeviceConfiguration.plist"
    
    // Internal Options
    case globalPreferences = "/var/Managed Preferences/mobile/.GlobalPreferences.plist"
    case appStore = "/var/Managed Preferences/mobile/com.apple.AppStore.plist"
    case backboardd = "/var/Managed Preferences/mobile/com.apple.backboardd.plist"
    case coreMotion = "/var/Managed Preferences/mobile/com.apple.CoreMotion.plist"
    case pasteboard = "/var/Managed Preferences/mobile/com.apple.Pasteboard.plist"
    case notes = "/var/Managed Preferences/mobile/com.apple.mobilenotes.plist"
    case uikit = "/var/Managed Preferences/mobile/com.apple.UIKit.plist"

    // Daemons
    case disabledDaemons = "/var/db/com.apple.xpc.launchd/disabled.plist"
    case screentime = "/var/mobile/Library/Preferences/ScreenTimeAgent.plist"

    // Risky Options
    case ota = "/var/Managed Preferences/mobile/com.apple.MobileAsset.plist"
}

enum ExploitError: Error, LocalizedError {
    case deviceNotConnected
    case deviceNotTrusted
    case deviceLocked
    case permissionDenied
    case commandExecutionFailed(String)
    case fileOperationFailed(String)
    case invalidOutputFormat
    case connectionInterrupted
    case operationTimedOut
    
    var localizedDescription: String {
        switch self {
        case .deviceNotConnected:
            return "未检测到连接的设备，请确保设备已通过USB连接到电脑"
        case .deviceNotTrusted:
            return "设备未信任此电脑，请在设备上点击'信任'按钮"
        case .deviceLocked:
            return "设备已锁定，请先解锁设备"
        case .permissionDenied:
            return "权限不足，无法执行此操作，请检查设备连接和权限设置"
        case .commandExecutionFailed(let command):
            return "执行命令失败: \(command)\n请确保设备已正确连接并信任此电脑"
        case .fileOperationFailed(let file):
            return "文件操作失败: \(file)\n请检查设备连接和文件路径是否正确"
        case .invalidOutputFormat:
            return "无效的输出格式，请重试操作"
        case .connectionInterrupted:
            return "设备连接已中断，请重新连接设备"
        case .operationTimedOut:
            return "操作超时，请重试或检查设备连接"
        }
    }
}

class ExploitManager: ObservableObject {
    static let shared = ExploitManager()
    
    private let toolsPath: String
    
    private init() {
        let bundlePath = Bundle.main.bundlePath
        toolsPath = bundlePath + "/Contents/Frameworks"
        setupCommandPermissions()
    }
    
    private func setupCommandPermissions() {
        let commands = ["idevice_id", "ideviceinfo", "idevicebackup2", "reboot"]
        
        for command in commands {
            let commandPath = toolsPath + "/" + command
            do {
                if FileManager.default.fileExists(atPath: commandPath) {
                    try FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: commandPath)
                }
            } catch {
                print("Failed to set permissions for \(command): \(error)")
            }
        }
    }
    
    func checkDeviceConnection() -> (Bool, String?) {
        let (success, output, error) = executeCommand("idevice_id", arguments: ["-l"])
        
        if !success {
            var errorMessage: String?
            if let error = error {
                if error.contains("No device found") {
                    errorMessage = "未检测到连接的设备"
                } else if error.contains("Could not connect to lockdownd") {
                    errorMessage = "无法连接到设备，请确保设备已信任此电脑"
                } else if error.contains("Permission denied") {
                    errorMessage = "权限不足，无法访问设备"
                } else {
                    errorMessage = "设备连接检查失败: \(error)"
                }
            } else {
                errorMessage = "无法检测设备连接状态"
            }
            return (false, errorMessage)
        }
        
        if output.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            return (false, "未检测到连接的设备")
        }
        
        return (true, nil)
    }
    
    func checkDeviceConnectionAsync() async -> (Bool, String?) {
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .background).async {
                let result = self.checkDeviceConnection()
                continuation.resume(returning: result)
            }
        }
    }
    
    func getDeviceUUID() -> String? {
        let (success, output, _) = executeCommand("idevice_id", arguments: ["-l"])
        if success && !output.isEmpty {
            return output.trimmingCharacters(in: .whitespacesAndNewlines)
        }
        return nil
    }
    
    func getDeviceInfo() -> (info: [String: String]?, error: String?) {
        guard let uuid = getDeviceUUID() else {
            return (nil, "无法获取设备UUID")
        }
        
        let (success, output, error) = executeCommand("ideviceinfo", arguments: ["-u", uuid])
        if !success {
            let errorMessage = error ?? "获取设备信息失败"
            return (nil, errorMessage)
        }
        
        var deviceInfo: [String: String] = [:]
        let lines = output.split(separator: "\n")
        
        for line in lines {
            if let separatorIndex = line.firstIndex(of: ":") {
                let key = String(line[..<separatorIndex]).trimmingCharacters(in: .whitespaces)
                let value = String(line[line.index(after: separatorIndex)...]).trimmingCharacters(in: .whitespaces)
                deviceInfo[key] = value
            }
        }
        
        if deviceInfo.isEmpty {
            return (nil, "未获取到有效的设备信息")
        }
        
        return (deviceInfo, nil)
    }
    
    func getDeviceInfoAsync() async -> (info: [String: String]?, error: String?) {
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .background).async {
                let result = self.getDeviceInfo()
                continuation.resume(returning: result)
            }
        }
    }
    
    func restartDevice() -> (Bool, String?) {
        // 首先检查设备是否已连接
        let (connected, connectionError) = checkDeviceConnection()
        if !connected {
            return (false, connectionError ?? "设备未连接")
        }
        
        // 获取设备UUID
        guard let uuid = getDeviceUUID() else {
            return (false, "无法获取设备UUID")
        }
        
        // 尝试使用系统的idevicediagnostics命令重启设备
        let (success, output, error) = executeCommand("idevicediagnostics", arguments: ["-u", uuid, "restart"])
        if success {
            return (true, nil)
        } else {
            var errorMsg = "Failed to restart device:"
            if let err = error {
                errorMsg += " " + err
            } else {
                errorMsg += " Unknown error"
            }
            return (false, errorMsg)
        }
    }
    
    // 直接执行命令的辅助方法
    private func executeCommandDirect(_ commandPath: String, arguments: [String] = []) -> (Bool, String, String?) {
        let task = Process()
        let outputPipe = Pipe()
        let errorPipe = Pipe()
        
        task.launchPath = commandPath
        task.arguments = arguments
        task.standardOutput = outputPipe
        task.standardError = errorPipe
        
        do {
            try task.run()
        } catch {
            let errorMsg = "执行命令失败: \(error.localizedDescription)"
            return (false, "", errorMsg)
        }
        
        task.waitUntilExit()
        
        let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: outputData, encoding: .utf8) ?? ""
        
        let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
        let errorOutput = String(data: errorData, encoding: .utf8) ?? ""
        
        // 根据命令和错误输出判断具体的错误类型
        var detailedError: String? = nil
        if task.terminationStatus != 0 {
            if errorOutput.contains("No device found") || errorOutput.contains("Could not connect to lockdownd") {
                detailedError = "设备未连接或未信任"
            } else if errorOutput.contains("Password required") || errorOutput.contains("Trust this computer") {
                detailedError = "需要在设备上解锁并信任此电脑"
            } else if errorOutput.contains("Permission denied") {
                detailedError = "权限不足，无法执行此操作"
            } else if errorOutput.contains("Connection reset") || errorOutput.contains("Connection terminated") {
                detailedError = "设备连接已中断"
            } else {
                detailedError = errorOutput.isEmpty ? "操作失败" : errorOutput
            }
        }
        
        return (task.terminationStatus == 0, output, detailedError)
    }
    
    func shutdownDevice() -> (Bool, String?) {
        guard let uuid = getDeviceUUID() else {
            return (false, "无法获取设备UUID")
        }
        
        // 检查idevicediagnostics是否存在
        let diagnosticsPath = toolsPath + "/idevicediagnostics"
        if !FileManager.default.fileExists(atPath: diagnosticsPath) {
            return (false, "设备诊断工具不存在")
        }
        
        let (success, output, error) = executeCommand("idevicediagnostics", arguments: ["-u", uuid, "shutdown"])
        if !success {
            let errorMessage = error ?? "关闭设备失败"
            return (false, errorMessage)
        }
        
        return (true, nil)
    }
    
    func getDeviceName() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["DeviceName"], error)
    }
    
    func getDeviceModel() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["ProductType"], error)
    }
    
    func getDeviceModelName() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["ModelName"], error)
    }
    
    func getiOSVersion() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["ProductVersion"], error)
    }
    
    func getSerialNumber() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["SerialNumber"], error)
    }
    
    func getSystemVersion() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        return (deviceInfo?["ProductVersion"], error)
    }
    
    func getSalesRegion() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        if let error = error {
            return (nil, error)
        }
        
        guard let deviceInfo = deviceInfo else {
            return (nil, "未获取到设备信息")
        }
        
        // 首先尝试从RegionInfo字段获取地区信息
        if let regionInfo = deviceInfo["RegionInfo"] {
            // 从RegionInfo中提取地区代码
            let components = regionInfo.split(separator: "/")
            if components.count > 0 {
                let regionCode = String(components[0])
                return (regionCode, nil)
            }
        }
        
        // 如果没有RegionInfo字段，再尝试从ModelNumber字段获取（作为备选方案）
        if let model = deviceInfo["ModelNumber"] {
            // 从型号末尾获取地区代码 (例如：MQA52CH/A -> CH)
            let components = model.split(separator: "/")
            if components.count > 1 {
                let regionCode = String(components[1])
                return (regionCode, nil)
            }
        }
        return (nil, "无法获取销售地区信息")
    }
    
    func getActivationStatus() -> (String?, String?) {
        let (deviceInfo, error) = getDeviceInfo()
        if let error = error {
            return (nil, error)
        }
        
        guard let deviceInfo = deviceInfo else {
            return (nil, "未获取到设备信息")
        }
        
        if let isActivated = deviceInfo["ActivationState"] {
            return (isActivated == "Activated" ? "已激活" : "未激活", nil)
        }
        return (nil, "无法获取激活状态")
    }
    
    func getJailbreakStatus() -> (String?, String?) {
        // 检查是否存在Cydia或Sileo等越狱应用
        guard let uuid = getDeviceUUID() else {
            return (nil, "无法获取设备UUID")
        }
        
        // 检查Cydia
        let cydiaResult = executeCommand("ideviceinfo", arguments: ["-u", uuid, "-q", "com.apple.mobile.house_arrest", "-o", "/var/mobile/Library/MobileInstallation/LastLaunchServicesMap.plist"])
        if cydiaResult.0 && cydiaResult.1.contains("Cydia") {
            return ("已越狱", nil)
        }
        
        // 检查Sileo
        let sileoResult = executeCommand("ideviceinfo", arguments: ["-u", uuid, "-q", "com.apple.mobile.house_arrest", "-o", "/var/mobile/Library/MobileInstallation/LastLaunchServicesMap.plist"])
        if sileoResult.0 && sileoResult.1.contains("Sileo") {
            return ("已越狱", nil)
        }
        
        // 检查Cydia安装目录
        let cydiaDirResult = executeCommand("ideviceinfo", arguments: ["-u", uuid, "-q", "com.apple.mobile.file_relay", "-o", "/etc/apt/sources.list.d/cydia.list"])
        if cydiaDirResult.0 {
            return ("已越狱", nil)
        }
        
        return ("未越狱", nil)
    }
    
    func getJailbreakStatusAsync() async -> String? {
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .background).async {
                let (status, _) = self.getJailbreakStatus()
                continuation.resume(returning: status)
            }
        }
    }
    
    // 从设备信息字典中提取信息的辅助方法，避免重复调用命令
    func getDeviceNameFromInfo(_ info: [String: String]) -> String? {
        return info["DeviceName"]
    }
    
    func getDeviceModelFromInfo(_ info: [String: String]) -> String? {
        return info["ProductType"]
    }
    
    func getDeviceModelNameFromInfo(_ info: [String: String]) -> String? {
        return info["ModelName"]
    }
    
    func getiOSVersionFromInfo(_ info: [String: String]) -> String? {
        return info["ProductVersion"]
    }
    
    func getSerialNumberFromInfo(_ info: [String: String]) -> String? {
        return info["SerialNumber"]
    }
    
    func getSystemVersionFromInfo(_ info: [String: String]) -> String? {
        return info["ProductVersion"]
    }
    
    func getSalesRegionFromInfo(_ info: [String: String]) -> String? {
        // 首先尝试从RegionInfo字段获取地区信息
        if let regionInfo = info["RegionInfo"] {
            // 从RegionInfo中提取地区代码
            let components = regionInfo.split(separator: "/")
            if components.count > 0 {
                return String(components[0])
            }
        }
        // 如果没有找到地区信息，返回nil
        return nil
    }
    
    func getActivationStatusFromInfo(_ info: [String: String]) -> String? {
        if let isActivated = info["ActivationState"] {
            return isActivated == "Activated" ? "已激活" : "未激活"
        }
        return nil
    }
    
    internal func executeCommand(_ command: String, arguments: [String] = []) -> (Bool, String, String?) {
        let task = Process()
        let outputPipe = Pipe()
        let errorPipe = Pipe()
        
        // 检查命令是否在允许列表中
        let allowedCommands = ["idevice_id", "ideviceinfo", "idevicediagnostics", "idevicebackup2", "reboot"]
        if !allowedCommands.contains(command) {
            let errorMsg = "不允许执行该命令: \(command)"
            return (false, "", errorMsg)
        }
        
        // 首先尝试使用应用程序包中的工具
        let appToolPath = toolsPath + "/" + command
        let systemToolPath = "/opt/homebrew/bin/" + command
        var foundPath: String?
        
        if FileManager.default.fileExists(atPath: appToolPath) {
            foundPath = appToolPath
        } else if FileManager.default.fileExists(atPath: systemToolPath) {
            // 对于所有命令，如果应用程序包中没有，尝试使用系统路径
            foundPath = systemToolPath
        } else {
            // 尝试使用which命令查找命令路径
            let (whichSuccess, whichOutput, whichError) = executeCommandDirect("/usr/bin/which", arguments: [command])
            if whichSuccess {
                foundPath = whichOutput.trimmingCharacters(in: .whitespacesAndNewlines)
                if foundPath?.isEmpty ?? true {
                    let errorMsg = "命令不存在: \(command)"
                    return (false, "", errorMsg)
                }
            } else {
                let errorMsg = "命令不存在: \(command) (\(whichError ?? "未知错误"))"
                return (false, "", errorMsg)
            }
        }
        
        guard let commandPath = foundPath else {
            let errorMsg = "无法找到命令路径: \(command)"
            return (false, "", errorMsg)
        }
        
        // 使用executeCommandDirect来执行命令，以便获取更详细的错误信息
        return executeCommandDirect(commandPath, arguments: arguments)
    }
    
    private func getPlistFromDevice(_ plistPath: String) -> (Data?, String?) {
        return extractPlistFromBackup(plistPath)
    }
    
    private func writePlistToDevice(_ plistData: Data, _ plistPath: String) -> (Bool, String?) {
        guard let uuid = getDeviceUUID() else {
            return (false, "无法获取设备UUID")
        }
        
        // 检查设备是否已连接
        let (connected, connectionError) = checkDeviceConnection()
        if !connected {
            return (false, connectionError)
        }
        
        // 创建临时目录
        let tempDir = NSTemporaryDirectory() + "device_backup_\(UUID().uuidString)"
        try? FileManager.default.createDirectory(atPath: tempDir, withIntermediateDirectories: true, attributes: nil)
        
        defer {
            try? FileManager.default.removeItem(atPath: tempDir)
        }
        
        // 使用idevicebackup2创建系统备份
        let (backupSuccess, _, backupError) = executeCommand("idevicebackup2", arguments: ["-u", uuid, "--system", "backup", tempDir])
        
        if !backupSuccess {
            return (false, backupError ?? "创建设备备份失败")
        }
        
        let backupInfoPath = tempDir + "/Manifest.plist"
        
        // 读取备份Manifest文件
        guard let manifestData = try? Data(contentsOf: URL(fileURLWithPath: backupInfoPath)),
              let manifest = try? PropertyListSerialization.propertyList(from: manifestData, options: [], format: nil) as? [String: Any],
              var files = manifest["Files"] as? [String: Any] else {
            return (false, "无法读取备份Manifest文件")
        }
        
        let fileName = (plistPath as NSString).lastPathComponent
        var fileUpdated = false
        
        // 查找并修改目标plist文件
        for (fileID, fileInfo) in files {
            if let fileDict = fileInfo as? [String: Any],
               let domain = fileDict["Domain"] as? String,
               let path = fileDict["Path"] as? String {
                
                // 多种可能的路径前缀
                let possiblePrefixes = [
                    "/",
                    "/var/preferences/",
                    "/var/mobile/Library/",
                    "/var/Managed Preferences/mobile/",
                    "/var/containers/Shared/SystemGroup/systemgroup.com.apple.configurationprofiles/Library/ConfigurationProfiles/",
                    "/var/db/"
                ]
                
                // 尝试所有可能的路径组合
                var foundMatch = false
                var matchedFullPath = ""
                
                // 首先检查文件名是否匹配（包括精确匹配和后缀匹配）
                if path == fileName || path.hasSuffix(fileName) || path.hasSuffix("/" + fileName) {
                    foundMatch = true
                    matchedFullPath = path
                }
                
                // 然后检查是否是隐藏文件（以.开头）
                if !foundMatch && fileName.hasPrefix(".") {
                    // 对于隐藏文件，检查完整路径是否包含文件名
                    if path.contains(fileName) || path.hasSuffix(fileName) {
                        foundMatch = true
                        matchedFullPath = path
                    }
                }
                
                // 然后尝试构建完整路径并检查是否匹配
                if !foundMatch {
                    for prefix in possiblePrefixes {
                        var fullPath: String
                        
                        // 根据 Domain 和 Prefix 构建完整路径
                        if domain == "System" {
                            fullPath = prefix + path
                        } else {
                            // 对于其他 Domain，尝试不同的路径组合
                            fullPath = prefix + path
                        }
                        
                        // 检查完整路径是否匹配我们要找的路径
                        if fullPath == plistPath {
                            foundMatch = true
                            matchedFullPath = fullPath
                            break
                        }
                        
                        // 额外检查：对于全局偏好设置文件的特殊处理
                        if fullPath.contains(".GlobalPreferences.plist") && plistPath.contains(".GlobalPreferences.plist") {
                            foundMatch = true
                            matchedFullPath = fullPath
                            break
                        }
                    }
                }
                
                if foundMatch {
                    let extractedPath = tempDir + "/" + fileID
                    do {
                        try plistData.write(to: URL(fileURLWithPath: extractedPath))
                        fileUpdated = true
                    } catch {
                        let errorMessage = "更新备份文件失败: \(error)"
                        return (false, errorMessage)
                    }
                }
            }
        }
        
        // 额外检查：如果没有找到文件，尝试直接匹配文件名，特别是对于.GlobalPreferences.plist
        if !fileUpdated {
            for (fileID, fileInfo) in files {
                if let fileDict = fileInfo as? [String: Any],
                   let path = fileDict["Path"] as? String {
                    if path.contains(".GlobalPreferences.plist") {
                        let extractedPath = tempDir + "/" + fileID
                        do {
                            try plistData.write(to: URL(fileURLWithPath: extractedPath))
                            fileUpdated = true
                            break
                        } catch {
                            let errorMessage = "更新备份文件失败: \(error)"
                            return (false, errorMessage)
                        }
                    }
                }
            }
        }
        
        if !fileUpdated {
            return (false, "在备份中未找到要更新的文件")
        }
        
        // 创建崩溃文件以绕过某些验证
        let crashFilePath = tempDir + "/crash_on_purpose"
        try? Data().write(to: URL(fileURLWithPath: crashFilePath))
        
        // 恢复修改后的文件到设备
        let (restoreSuccess, _, restoreError) = executeCommand("idevicebackup2", arguments: ["-u", uuid, "--system", "restore", tempDir])
        
        if !restoreSuccess {
            return (false, restoreError ?? "将修改后的文件恢复到设备失败")
        }
        
        return (true, nil)
    }
    
    private func extractPlistFromBackup(_ plistPath: String) -> (Data?, String?) {
        guard let uuid = getDeviceUUID() else {
            return (nil, "无法获取设备UUID")
        }
        
        // 检查设备是否已连接
        let (connected, connectionError) = checkDeviceConnection()
        if !connected {
            return (nil, connectionError)
        }
        
        let tempDir = NSTemporaryDirectory() + "device_backup_\(UUID().uuidString)"
        try? FileManager.default.createDirectory(atPath: tempDir, withIntermediateDirectories: true, attributes: nil)
        
        defer {
            try? FileManager.default.removeItem(atPath: tempDir)
        }
        
        // 创建系统备份
        let (backupSuccess, _, backupError) = executeCommand("idevicebackup2", arguments: ["-u", uuid, "--system", "backup", tempDir])
        
        if !backupSuccess {
            let errorMessage = backupError ?? "创建设备备份失败"
            return (nil, errorMessage)
        }
        
        let backupInfoPath = tempDir + "/Manifest.plist"
        
        guard let manifestData = try? Data(contentsOf: URL(fileURLWithPath: backupInfoPath)),
              let manifest = try? PropertyListSerialization.propertyList(from: manifestData, options: [], format: nil) as? [String: Any],
              let files = manifest["Files"] as? [String: Any] else {
            return (nil, "无法读取备份Manifest文件")
        }
        
        let fileName = (plistPath as NSString).lastPathComponent
        
        for (fileID, fileInfo) in files {
            if let fileDict = fileInfo as? [String: Any],
               let domain = fileDict["Domain"] as? String,
               let path = fileDict["Path"] as? String {
                
                // 检查文件名是否匹配
                if path == fileName || path.hasSuffix(fileName) || path.hasSuffix("/" + fileName) {
                    let extractedPath = tempDir + "/" + fileID
                    do {
                        let data = try Data(contentsOf: URL(fileURLWithPath: extractedPath))
                        return (data, nil)
                    } catch {
                        let errorMessage = "读取备份文件失败: \(error)"
                        return (nil, errorMessage)
                    }
                }
                
                // 检查是否是隐藏文件（以.开头）
                if fileName.hasPrefix(".") && (path.contains(fileName) || path.hasSuffix(fileName)) {
                    let extractedPath = tempDir + "/" + fileID
                    do {
                        let data = try Data(contentsOf: URL(fileURLWithPath: extractedPath))
                        return (data, nil)
                    } catch {
                        let errorMessage = "读取备份文件失败: \(error)"
                        return (nil, errorMessage)
                    }
                }
                
                // 多种可能的路径前缀
                let possiblePrefixes = [
                    "/",
                    "/var/preferences/",
                    "/var/mobile/Library/",
                    "/var/Managed Preferences/mobile/",
                    "/var/containers/Shared/SystemGroup/systemgroup.com.apple.configurationprofiles/Library/ConfigurationProfiles/",
                    "/var/db/"
                ]
                
                // 尝试所有可能的路径组合
                for prefix in possiblePrefixes {
                    var fullPath: String
                    
                    // 根据 Domain 和 Prefix 构建完整路径
                    if domain == "System" {
                        fullPath = prefix + path
                    } else {
                        // 对于其他 Domain，尝试不同的路径组合
                        fullPath = prefix + path
                    }
                    
                    // 检查完整路径是否匹配我们要找的路径
                    if fullPath == plistPath {
                        let extractedPath = tempDir + "/" + fileID
                        do {
                            let data = try Data(contentsOf: URL(fileURLWithPath: extractedPath))
                            return (data, nil)
                        } catch {
                            let errorMessage = "读取备份文件失败: \(error)"
                            return (nil, errorMessage)
                        }
                    }
                }
                
                // 额外检查：只使用文件名匹配
                if path == fileName || path.hasSuffix(fileName) {
                    let extractedPath = tempDir + "/" + fileID
                    do {
                        let data = try Data(contentsOf: URL(fileURLWithPath: extractedPath))
                        return (data, nil)
                    } catch {
                        let errorMessage = "读取备份文件失败: \(error)"
                        return (nil, errorMessage)
                    }
                }
                
                // 额外检查：对于全局偏好设置文件的特殊处理
                if path.contains(".GlobalPreferences.plist") && plistPath.contains(".GlobalPreferences.plist") {
                    let extractedPath = tempDir + "/" + fileID
                    do {
                        let data = try Data(contentsOf: URL(fileURLWithPath: extractedPath))
                        return (data, nil)
                    } catch {
                        let errorMessage = "读取备份文件失败: \(error)"
                        return (nil, errorMessage)
                    }
                }
            }
        }
        
        return (nil, "在备份中未找到要读取的文件")
    }
    
    func setDisableLiquidGlass(_ enabled: Bool, completion: @escaping (Bool, String?) -> Void) {
        DispatchQueue.global(qos: .background).async {[weak self] in
            guard let self = self else { return }
            let result = self.setPlistValue(enabled, key: "com.apple.SwiftUI.DisableSolarium", fileLocation: .globalPreferences)
            DispatchQueue.main.async {
                completion(result.0, result.1)
            }
        }
    }
    
    func setIgnoreLiquidGlassAppBuildCheck(_ enabled: Bool, completion: @escaping (Bool, String?) -> Void) {
        DispatchQueue.global(qos: .background).async {[weak self] in
            guard let self = self else { return }
            let result = self.setPlistValue(enabled, key: "com.apple.SwiftUI.IgnoreSolariumLinkedOnCheck", fileLocation: .globalPreferences)
            DispatchQueue.main.async {
                completion(result.0, result.1)
            }
        }
    }
    
    // 使用新Restore功能的setPlistValue方法
    private func setPlistValue<T>(_ value: T, key: String, fileLocation: PlistFileLocation) -> (Bool, String?) {
        do {
            // 获取目标文件路径
            let targetPath = fileLocation.rawValue
            
            // 读取当前plist文件（如果存在）
            var plistDict: [String: Any] = [:]
            
            // 使用已有的getPlistFromDevice方法获取当前plist内容
            let (currentPlistData, error) = self.getPlistFromDevice(targetPath)
            if let currentPlistData = currentPlistData {
                if let existingDict = try? PropertyListSerialization.propertyList(from: currentPlistData, options: [], format: nil) as? [String: Any] {
                    plistDict = existingDict
                }
            }
            
            // 修改plist值
            plistDict[key] = value
            
            // 创建plist数据
            let plistData = try PropertyListSerialization.data(fromPropertyList: plistDict, format: .binary, options: 0)
            
            // 使用writePlistToDevice方法将修改后的plist写入设备
            return writePlistToDevice(plistData, targetPath)
            
        } catch {
            return (false, error.localizedDescription)
        }
    }
    

}
